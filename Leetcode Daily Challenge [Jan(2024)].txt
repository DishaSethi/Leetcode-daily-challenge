January 1
Assign Cookies(easy)
Time complexity:O(nlogn)
Space complexity: O(1)
Soln:
class Solution {
   
    public int findContentChildren(int[] g, int[] s) {
    int cookieNums=s.length;
    if(cookieNums==0) return 0;


    Arrays.sort(g);
    Arrays.sort(s);


    int cookieIndex=s.length-1;
    int childIndex=g.length-1;
int maxNum=0;
while(cookieIndex>=0 && childIndex>=0){
    if(s[cookieIndex]>=g[childIndex]){
        maxNum++;
        cookieIndex--;
        childIndex--;
    }
    else{
        childIndex--;
    }
}
return maxNum;


    }
}






January 2
Convert an array into a 2D array with conditions(Medium)


My soln:
import java.util.*;
class Solution {
   
    public List<List<Integer>> findMatrix(int[] nums) {
             ArrayList<List<Integer> > twoD
            = new ArrayList<List<Integer> >();
List<Integer> numslist=new ArrayList<Integer> ();
for(int i=0;i<nums.length;i++){
    numslist.add(nums[i]);
}
int count=0;
while( count!=nums.length){
    List<Integer> list1=new ArrayList<Integer>();
    int i=0;
    while(i!=numslist.size()){
if(list1.contains(numslist.get(i))==false){
list1.add(numslist.get(i));
count++;
numslist.remove(numslist.get(i));


}
else{i++;}


    }


    twoD.add(list1);
}
return twoD;


    }
}


Best optimised soln: Time complexity:
        O(n).   Space complexity:O(n)
import java.util.*;


class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
        int[] freq = new int[nums.length + 1];
        List<List<Integer>> ans = new ArrayList<>();


        for (int c : nums) {
            if (freq[c] >= ans.size()) {
                ans.add(new ArrayList<>());
            }


            ans.get(freq[c]).add(c);
            freq[c]++;
        }


        return ans;
    }
}




January 4
Minimum number of operations to make an array empty
My soln:
Time - 27ms Time complexity : O(n) & space complexity:O(n)
class Solution {
    public int minOperations(int[] nums) {
        HashMap<Integer,Integer> hm=new HashMap<>();
int ans=0;
        for(int i=0;i<nums.length;i++){
          if(hm.containsKey(nums[i])==true){
              hm.put(nums[i],hm.get(nums[i])+1);
          }else{
              hm.put(nums[i],1);
          }
        }


      for(Integer key:hm.keySet()){
          if(hm.get(key)==1){
              ans=-1;
              break;
          }
          if(hm.get(key)%3==0){
              ans=ans+(hm.get(key)/3);
          }else if((hm.get(key)%3==1 || hm.get(key)%3==2)){
        int count=  hm.get(key);
        while(count%3!=0 && count!=1){
            count=count-2;
            ans++;
        }
        ans=ans+count/3;
          }else if(hm.get(key)%2==0){
              ans=ans+hm.get(key)/2;
          }


          }
     
      return ans;
    }
}
Other soln:
Faster
Time-21ms Time complexity-O(n) & space complexity - O(n)
import java.util.HashMap;
import java.util.Map;


class Solution {
    public int minOperations(int[] nums) {
        // Create a HashMap to store the frequency of each element in 'nums'
        Map<Integer, Integer> mp = new HashMap<>();
       
        // Count the frequency of each element in 'nums'
        for (int num : nums) {
            // Put the element in the map and increment its count by 1
            mp.put(num, mp.getOrDefault(num, 0) + 1);
        }
       
        // Initialize a variable to count the minimum operations needed
        int count = 0;
       
        // Iterate through the entries in the HashMap
        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
            // Get the frequency count of the current element
            int t = entry.getValue();
           
            // If there is only one occurrence of any element, it's not possible to make it divisible by 3
            if (t == 1)
                return -1;
           
            // Calculate the number of operations needed to make the frequency divisible by 3
            count += t / 3; // Count the complete sets of 3 elements
            if (t % 3 != 0) // If there are remaining elements, increment the count
                count++;
        }
       
        // Return the total count of operations needed
        return count;
    }
}








January 8 
Range Sum of BST(easy)
Time Complexity: O(n) as we visit all the nodes once
Space Complexity: O(log n) for a balanced binary tree.
For an unbalanced one it is O(n)
My soln:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root==null){
            return 0;
        }
int sum=0;
        if(root.val>=low && root.val<=high){
            return  root.val+rangeSumBST(root.left, low , high)+rangeSumBST(root.right,low,high);


        }else{
            return rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);
        }
    }
}






January 9
Leaf 
Time Complexity:  O(n)
Space Complexity:O(h1+h2) h1 ans h2 are heights of the two trees
My soln:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        ArrayList<Integer> lv1=new ArrayList<Integer>();
          ArrayList<Integer> lv2=new ArrayList<Integer>();
          collectLeafValues(root1,lv1);
          collectLeafValues(root2,lv2);
         
          return lv1.equals(lv2);




    }
  public void collectLeafValues(TreeNode root, ArrayList lv){
 if(root==null){
     return;
 }
 if(root.right==null && root.left==null){
   lv.add(root.val);
   
 }
     collectLeafValues(root.right,lv);
     collectLeafValues(root.left,lv);
 
 


  }
   
}